"Create OpenBabel fingerprints"

# Copyright (c) 2010 Andrew Dalke Scientific, AB (Gothenburg, Sweden)
# See the contents of "__init__.py" for full license details.

from __future__ import absolute_import

import sys
import os
import struct
import warnings

import openbabel as ob

# OpenBabel really wants these two variables. I get a segfault if
# BABEL_LIBDIR isn't defined, and from the mailing list, some of the
# code doesn't work correctly without BABEL_DATADIR. I've had problems
# where I forget to set these variables, so check for them now and
# warn about possible problems.

if "BABEL_LIBDIR" not in os.environ:
    warnings.warn("BABEL_LIBDIR is not set; this process may soon crash")
#else:
#  ... check that SMILES and a few other things are on the path ...
#  but note that BABEL_LIBDIR is a colon (or newline or control-return?)
#  separated field whose behaviour isn't well defined in the docs.
#  I'm not going to do additional checking without a stronger need.

if "BABEL_DATADIR" not in os.environ:
    warnings.warn("Missing BABEL_DATADIR definition")

# This is the only thing which I consider to be public
__all__ = ["read_structures"]

# This is a "standard" size according to the struct module
# documentation, so the following is an excess of caution
if struct.calcsize("<I") != 4:
    raise AssertionError("The chemfp.ob module assumes 32 bit integers")


# OpenBabel before 2.3 didn't have a function to return the version.
# I've brought this up on the list, and it's in 2.3. I can fake
# support for older lists by reading the PDB output text.

def _emulated_GetReleaseVersion():
    "GetReleaseVersion() -> the version string for the OpenBabel toolkit"
    obconversion = ob.OBConversion()
    obconversion.SetInFormat("smi")
    obconversion.SetOutFormat("pdb")
    obmol = ob.OBMol()
    
    obconversion.ReadString(obmol, "C")
    for line in obconversion.WriteString(obmol).splitlines():
        if "GENERATED BY OPEN BABEL" in line:
            return line.split()[-1]
    return "<unknown>"

try:
    from openbabel import GetReleaseVersion
except ImportError:
    GetReleaseVersion = _emulated_GetReleaseVersion
_ob_version = GetReleaseVersion()

SOFTWARE = "OpenBabel/" + _ob_version


# OpenBabel fingerprints are stored as vector<unsigned int>.  On all
# the machines I use, ints have 32 bits.

# OpenBabel bit lengths must be at least sizeof(int)*8 bits long and
# must be a factor of two. I have no idea why this is required.

# OpenBabel supports new fingerprints through a plugin system.  I got
# it working thanks to Noel O'Boyle's excellent work with Cinfony. I
# then found out that the OB API doesn't have any way to get the
# number of bits in the fingerprint. The size is rounded up to the
# next power of two, so FP4 (307 bits) needs 512 bits (16 ints)
# instead of 320 bits (10 ints). That means I can't even get close to
# guessing the bitsize.

# In the end, I hard-coded the supported fingerprints into the system.



############

# I could have written a more general function which created these but
# there's only a few fingerprints lengths to worry about.

# This needs 128 bytes, for 1024 bits
# vectorUnsignedInt will contain 32 32-bit words = 1024 bits

_ob_get_fingerprint = {}
def _init():
    for name in ("FP2", "FP3", "FP4", "MACCS"):
        ob_fingerprinter = ob.OBFingerprint.FindFingerprint(name)
        if ob_fingerprinter is None:
            _ob_get_fingerprint[name] = (None, None)
        else:
            _ob_get_fingerprint[name] = (ob_fingerprinter, ob_fingerprinter.GetFingerprint)
_init()

def calc_FP2(mol, fp=None,
             get_fingerprint=_ob_get_fingerprint["FP2"][1],
             _pack_1024 = struct.Struct("<" + "I"*32).pack):
    if fp is None:
        fp = ob.vectorUnsignedInt()
    get_fingerprint(mol, fp)
    return _pack_1024(*fp)

# This needs 7 bytes, for 56 bits.
# vectorUnsignedInt will contain 2 32-bit words = 64 bits
def calc_FP3(mol, fp=None,
             get_fingerprint=_ob_get_fingerprint["FP3"][1],
             _pack_64 = struct.Struct("<II").pack):
    if fp is None:
        fp = ob.vectorUnsignedInt()
    get_fingerprint(mol, fp)
    return _pack_64(*fp)[:7]

# This needs 39 bytes, for 312 bits
# vectorUnsignedInt will contain 16 32-bit words = 512 bits
def calc_FP4(mol, fp=None,
             get_fingerprint=_ob_get_fingerprint["FP4"][1],
             _pack_512 = struct.Struct("<" + "I"*16).pack):
    if fp is None:
        fp = ob.vectorUnsignedInt()
    get_fingerprint(mol, fp)
    return _pack_512(*fp)[:39]

# This needs 21 bytes, for 166 bits
# vectorUnsignedInt will contain 8 32-bit words = 256 bits
# (Remember, although 6 words * 32-bits/word = 192, the OpenBabel
# fingerprint size must be a power of 2, and the closest is 8*32.)
def calc_MACCS(mol, fp=None,
               get_fingerprint=_ob_get_fingerprint["MACCS"][1],
               _pack_256 = struct.Struct("<" + "I"*8).pack):
    if fp is None:
        fp = ob.vectorUnsignedInt()
    get_fingerprint(mol, fp)
    return _pack_256(*fp)[:21]


class BaseFingerprinterInfo(object):
    def __init__(self, ob_fingerprinter):
        self.ob_fingerprinter = ob_fingerprinter

    @property
    def description(self):
        return self.ob_fingerprinter.Description()

    @property
    def fps_type(self):
        return "OpenBabel-" + self.name + "/1"

class FP2FingerprinterInfo(BaseFingerprinterInfo):
    name = "FP2"
    num_bits = 1021
    calc_fp = staticmethod(calc_FP2)

class FP3FingerprinterInfo(BaseFingerprinterInfo):
    name = "FP3"
    num_bits = 55
    calc_fp = staticmethod(calc_FP3)

class FP4FingerprinterInfo(BaseFingerprinterInfo):
    name = "FP4"
    num_bits = 307
    calc_fp = staticmethod(calc_FP4)

class MACCSFingerprinterInfo(BaseFingerprinterInfo):
    name = "MACCS"
    num_bits = 166
    calc_fp = staticmethod(calc_MACCS)
    _fps_type = None

    @property
    def fps_type(self):
        _fps_type = self._fps_type
        if _fps_type is None:
            # OpenBabel 2.3.0 released the MACCS keys but with a bug in the SMARTS.
            # While they are valid substructure keys, they are not really MACCS keys.
            # This is a run-time detection to figure out which version was installed
            obconversion = ob.OBConversion()
            obconversion.SetInFormat("smi")
            obmol = ob.OBMol()
            obconversion.ReadString(obmol, "C1CCC1")
            fp = calc_MACCS(obmol)
            if fp[:6] == "000020":
                _fps_type = "OpenBabel-MACCS/1" # the buggy version
            else:
                _fps_type = "OpenBabel-MACCS/2" # the corrected version
            self._fps_type = _fps_type
        return _fps_type

_fingerprinter_table = {}

def _init():
    g = globals()
    for fp_name, (ob_fingerprinter, get_fingerprint) in _ob_get_fingerprint.items():
        klass = g[fp_name + "FingerprinterInfo"]
        fingerprinter = klass(ob_fingerprinter)
        _fingerprinter_table[fingerprinter.name] = fingerprinter
            

    # Verify that OpenBabel was compiled with 32 bit integers
    n = _fingerprinter_table["FP2"].ob_fingerprinter.Getbitsperint()
    if n != 32:
        raise AssertionError(
            "The chemfp.ob module assumes OB fingerprints have 32 bits per integer")

_init()
#########


def _guess_format_from_filename(filename):
    "This is an internal function"
    # Guess the format based on the filename extension
    base, ext = os.path.splitext(filename.lower())
    if ext in ("", "."):
        # No extension? Assume smiles
        return "smi"

    if ext != ".gz":
        # Not compressed? Use whatever was given.
        return ext[1:] # remove leading "."

    # Compressed? Get the next extension
    base, ext = os.path.splitext(base)
    if ext in ("", "."):
        # No extension? Assume smiles
        return "smi"

    # Use the 2nd level extension
    return ext[1:] # remove leading "."

def normalize_format(filename, format):
    """normalize_format(filename, format) -> normalized format name

    This is perhaps easiestly explained by example:
        ("input.dat", "smi.gz") -> "smi"   (format takes precedence)
        ("input.smi", "sdf") -> "sdf"
        ("INPUT.SDF", None) -> "sdf"       (otherwise use the filename)
        ("input.pdb.gz", None) -> "pdb"
        (None, None) -> "smi"              (otherwise it's SMILES)

    In words, get an OpenBabel format name given an input filename and
    format. The rules are:
      - Convert input strings to lower-case.
      - Remove the ".gz" suffix from each, if present.
      - If the format is not None, return it as the normalized format.
      - If the filename is not None, return the suffix.
      - If the filename has an extension, use that as the format.
      - Otherwise, it's in "smi" format.
    """
    if format is not None:
        format = format.lower()
        # Ignore .gz - Babel handles those automatically
        if format.endswith(".gz"):
            format = format[:-3]
        return format

    if filename is not None:
        return _guess_format_from_filename(filename)

    # Use SMILES by default for stdin
    return "smi"


def _get_ob_error(log):
    msgs = log.GetMessagesOfLevel(ob.obError)
    return "".join(msgs)

def get_fingerprinter(fp_type):
    for (fp_name, fp_info) in _fingerprinter_table.items():
        if fp_info.fp_type == fp_type:
            return fp_info.calc_fp
    raise TypeError("Unsupported fingerprint type: %r" % (fp_type,))
    

def read_structures(filename=None, format=None):
    """read_structures(filename, format) -> (title, OBMol) iterator 
    
    Iterate over structures from filename, returning the structure
    title and OBMol for each reacord. The structure is assumed to be
    in normalized_format(filename, format) format. If filename is None
    then this reads from stdin instead of the named file.
    """
    obconversion = ob.OBConversion()

    format = normalize_format(filename, format)
    if not obconversion.SetInFormat(format):
        raise TypeError("Unknown structure format {format!r}".format(format=format))
    
    obmol = ob.OBMol()

    if not filename:
        # OpenBabel's Python libary has no way to read from std::cin
        # Fake it through /dev/stdin for those OSes which support it.
        if not os.path.exists("/dev/stdin"):
            raise TypeError("Unable to read from stdin on this platform")

        return _stdin_reader(obconversion, obmol)

    # Deal with OpenBabel's logging
    ob.obErrorLog.ClearLog()
    lvl = ob.obErrorLog.GetOutputLevel()
    ob.obErrorLog.SetOutputLevel(-1) # Suppress messages to stderr

    notatend = obconversion.ReadFile(obmol, filename)

    if ob.obErrorLog.GetErrorMessageCount():
        # The OB error messages are not that helpful. Do
        # some probing of my own before going to OB's message.
        try:
            open(filename).close()
        except IOError, err:
            raise SystemExit("Unable to open structure file {filename!r}: {msg}".format(
                filename=filename, msg=err.strerror))

        # Okay, don't know what's going on. Report OB's error
        errmsg = _get_ob_error(ob.obErrorLog)
        raise SystemExit("Unable to get structures from {filename!r|:\n{msg}".format(
            filename=filename, msg=errmsg))

    ob.obErrorLog.SetOutputLevel(lvl) # Revert to normal logging

    # We've opened the file. Switch to the iterator.
    return _file_reader(obconversion, obmol, notatend)

def _stdin_reader(obconversion, obmol):
    "This is an internal function"
    # Read structures from stdin.

    # The current release of scripting for OpenBabel doesn't let me
    # use C++'s std::cin as the input stream so I need to fake it
    # using "/dev/stdin". That works on Macs, Linux, and FreeBSD but
    # not Windows.

    # Python says that it's in charge of checking for ^C. When I pass
    # control over to OpenBabel, Python is still in charge of checking
    # for ^C, but it won't do anything until control returns to Python.

    # I found it annoying that if I started the program, which by
    # default expects SMILES from stdin, then I couldn't hit ^C to
    # stop it. My solution was to stay in Python until there's
    # information on stdin, and once that's happened, call OpenBabel.

    import select
    try:
        select.select([sys.stdin], [], [sys.stdin])
    except KeyboardInterrupt:
        raise SystemExit()

    # There's data. Pass parsing control into OpenBabel.
    notatend = obconversion.ReadFile(obmol, "/dev/stdin")
    return _file_reader(obconversion, obmol, notatend)

def _file_reader(obconversion, obmol, notatend):
    while notatend:
        yield obmol.GetTitle(), obmol
        obmol.Clear()
        notatend = obconversion.Read(obmol)
        # How do I detect if the input contains a failure?
