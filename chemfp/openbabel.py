"Create OpenBabel fingerprints"

# Copyright (c) 2010 Andrew Dalke Scientific, AB (Gothenburg, Sweden)
# See the contents of "__init__.py" for full license details.

from __future__ import absolute_import

import sys
import os
import struct
import warnings

import openbabel as ob

# OpenBabel really wants these two variables. I get a segfault if
# BABEL_LIBDIR isn't defined, and from the mailing list, some of the
# code doesn't work correctly without BABEL_DATADIR. I've had problems
# where I forget to set these variables, so check for them now and
# warn about possible problems.

if "BABEL_LIBDIR" not in os.environ:
    warnings.warn("BABEL_LIBDIR is not set; this process may soon crash")
#else:
#  ... check that SMILES and a few other things are on the path ...
#  but note that BABEL_LIBDIR is a colon (or newline or control-return?)
#  separated field whose behaviour isn't well defined in the docs.
#  I'm not going to do additional checking without a stronger need.

if "BABEL_DATADIR" not in os.environ:
    warnings.warn("Missing BABEL_DATADIR definition")

# This is the only thing which I consider to be public
__all__ = ["read_structures"]

# This is a "standard" size according to the struct module
# documentation, so the following is an excess of caution
if struct.calcsize("<I") != 4:
    raise AssertionError("The chemfp.ob module assumes 32 bit integers")


# OpenBabel before 2.3 didn't have a function to return the version.
# I've brought this up on the list, and it's in 2.3. I can fake
# support for older lists by reading the PDB output text.

def _emulated_GetReleaseVersion():
    "GetReleaseVersion() -> the version string for the OpenBabel toolkit"
    obconversion = ob.OBConversion()
    obconversion.SetInFormat("smi")
    obconversion.SetOutFormat("pdb")
    obmol = ob.OBMol()
    
    obconversion.ReadString(obmol, "C")
    for line in obconversion.WriteString(obmol).splitlines():
        if "GENERATED BY OPEN BABEL" in line:
            return line.split()[-1]
    return "<unknown>"

try:
    from openbabel import GetReleaseVersion
except ImportError:
    GetReleaseVersion = _emulated_GetReleaseVersion
_ob_version = GetReleaseVersion()

SOFTWARE = "OpenBabel/" + _ob_version


# OpenBabel fingerprints are stored as vector<unsigned int>.  On all
# the machines I use, ints have 32 bits.

# OpenBabel bit lengths must be at least sizeof(int)*8 bits long and
# must be a factor of two. I have no idea why this is required.

# OpenBabel supports new fingerprints through a plugin system.  I got
# it working thanks to Noel O'Boyle's excellent work with Cinfony. I
# then found out that the OB API doesn't have any way to get the
# number of bits in the fingerprint. The size is rounded up to the
# next power of two, so FP4 (307 bits) needs 512 bits (16 ints)
# instead of 320 bits (10 ints). That means I can't even get close to
# guessing the bitsize.

# In the end, I hard-coded the supported fingerprints into the system.

class FingerprinterInfo(object):
    def __init__(self, name, description, ob_fingerprinter, num_bits):
        self.name = name
        self.description = description
        self.ob_fingerprinter = ob_fingerprinter
        self.num_bits = num_bits

        self.fps_type = "OpenBabel-" + name + "/1"

        # This is filled in later with the function which computes the
        # fingerprint as a string of bytes.
        self.calc_fp = None

_fingerprinter_table = {}

def _init():
    for name, num_bits in ( ("FP2", 1021),
                            ("FP3", 55),
                            ("FP4", 307),
                            ("MACCS", 166), # Added in OpenBabel 2.3
                            ):
        ob_fingerprinter = ob.OBFingerprint.FindFingerprint(name)
        if ob_fingerprinter is None:
            # Older version of OpenBabel; no support for this fingerprint type
            continue
        description = ob_fingerprinter.Description()

        _fingerprinter_table[name] = FingerprinterInfo(
            name, description, ob_fingerprinter, num_bits)

    # Verify that OpenBabel was compiled with 32 bit integers
    n = _fingerprinter_table["FP2"].ob_fingerprinter.Getbitsperint()
    if n != 32:
        raise AssertionError(
            "The chemfp.ob module assumes OB fingerprints have 32 bits per integer")
_init()


############

# I could have written a more general function which created these but
# there's only a few fingerprints lengths to worry about.

# This needs 128 bytes, for 1024 bits
# vectorUnsignedInt will contain 32 32-bit words = 1024 bits
def calc_FP2(mol, fp=None,
             get_fingerprint=_fingerprinter_table["FP2"].ob_fingerprinter.GetFingerprint,
             _pack_1024 = struct.Struct("<" + "I"*32).pack):
    if fp is None:
        fp = ob.vectorUnsignedInt()
    get_fingerprint(mol, fp)
    return _pack_1024(*fp)

# This needs 7 bytes, for 56 bits.
# vectorUnsignedInt will contain 2 32-bit words = 64 bits
def calc_FP3(mol, fp=None,
             get_fingerprint=_fingerprinter_table["FP3"].ob_fingerprinter.GetFingerprint,
             _pack_64 = struct.Struct("<II").pack):
    if fp is None:
        fp = ob.vectorUnsignedInt()
    get_fingerprint(mol, fp)
    return _pack_64(*fp)[:7]

# This needs 39 bytes, for 312 bits
# vectorUnsignedInt will contain 16 32-bit words = 512 bits
def calc_FP4(mol, fp=None,
             get_fingerprint=_fingerprinter_table["FP4"].ob_fingerprinter.GetFingerprint,
             _pack_512 = struct.Struct("<" + "I"*16).pack):
    if fp is None:
        fp = ob.vectorUnsignedInt()
    get_fingerprint(mol, fp)
    return _pack_512(*fp)[:39]

# This needs 21 bytes, for 166 bits
# vectorUnsignedInt will contain 8 32-bit words = 256 bits
# (Remember, although 6 words * 32-bits/word = 192, the OpenBabel
# fingerprint size must be a power of 2, and the closest is 8*32.)
def calc_MACCS(mol, fp=None,
               get_fingerprint=_fingerprinter_table["MACCS"].ob_fingerprinter.GetFingerprint,
               _pack_256 = struct.Struct("<" + "I"*8).pack):
    if fp is None:
        fp = ob.vectorUnsignedInt()
    get_fingerprint(mol, fp)
    return _pack_256(*fp)[:21]


_fingerprinter_table["FP2"].calc_fp = calc_FP2
_fingerprinter_table["FP3"].calc_fp = calc_FP3
_fingerprinter_table["FP4"].calc_fp = calc_FP4
_fingerprinter_table["MACCS"].calc_fp = calc_MACCS

#########


def _guess_format_from_filename(filename):
    "This is an internal function"
    # Guess the format based on the filename extension
    base, ext = os.path.splitext(filename.lower())
    if ext in ("", "."):
        # No extension? Assume smiles
        return "smi"

    if ext != ".gz":
        # Not compressed? Use whatever was given.
        return ext[1:] # remove leading "."

    # Compressed? Get the next extension
    base, ext = os.path.splitext(base)
    if ext in ("", "."):
        # No extension? Assume smiles
        return "smi"

    # Use the 2nd level extension
    return ext[1:] # remove leading "."

def normalize_format(filename, format):
    """normalize_format(filename, format) -> normalized format name

    This is perhaps easiestly explained by example:
        ("input.dat", "smi.gz") -> "smi"   (format takes precedence)
        ("input.smi", "sdf") -> "sdf"
        ("INPUT.SDF", None) -> "sdf"       (otherwise use the filename)
        ("input.pdb.gz", None) -> "pdb"
        (None, None) -> "smi"              (otherwise it's SMILES)

    In words, get an OpenBabel format name given an input filename and
    format. The rules are:
      - Convert input strings to lower-case.
      - Remove the ".gz" suffix from each, if present.
      - If the format is not None, return it as the normalized format.
      - If the filename is not None, return the suffix.
      - If the filename has an extension, use that as the format.
      - Otherwise, it's in "smi" format.
    """
    if format is not None:
        format = format.lower()
        # Ignore .gz - Babel handles those automatically
        if format.endswith(".gz"):
            format = format[:-3]
        return format

    if filename is not None:
        return _guess_format_from_filename(filename)

    # Use SMILES by default for stdin
    return "smi"


def _get_ob_error(log):
    msgs = log.GetMessagesOfLevel(ob.obError)
    return "".join(msgs)

def read_structures(filename=None, format=None):
    """read_structures(filename, format) -> (title, OBMol) iterator 
    
    Iterate over structures from filename, returning the structure
    title and OBMol for each reacord. The structure is assumed to be
    in normalized_format(filename, format) format. If filename is None
    then this reads from stdin instead of the named file.
    """
    obconversion = ob.OBConversion()

    format = normalize_format(filename, format)
    if not obconversion.SetInFormat(format):
        raise TypeError("Unknown structure format {format!r}".format(format=format))
    
    obmol = ob.OBMol()

    if not filename:
        # OpenBabel's Python libary has no way to read from std::cin
        # Fake it through /dev/stdin for those OSes which support it.
        if not os.path.exists("/dev/stdin"):
            raise TypeError("Unable to read from stdin on this platform")

        return _stdin_reader(obconversion, obmol)

    # Deal with OpenBabel's logging
    ob.obErrorLog.ClearLog()
    lvl = ob.obErrorLog.GetOutputLevel()
    ob.obErrorLog.SetOutputLevel(-1) # Suppress messages to stderr

    notatend = obconversion.ReadFile(obmol, filename)

    if ob.obErrorLog.GetErrorMessageCount():
        # The OB error messages are not that helpful. Do
        # some probing of my own before going to OB's message.
        try:
            open(filename).close()
        except IOError, err:
            raise SystemExit("Unable to open structure file {filename!r}: {msg}".format(
                filename=filename, msg=err.strerror))

        # Okay, don't know what's going on. Report OB's error
        errmsg = _get_ob_error(ob.obErrorLog)
        raise SystemExit("Unable to get structures from {filename!r|:\n{msg}".format(
            filename=filename, msg=errmsg))

    ob.obErrorLog.SetOutputLevel(lvl) # Revert to normal logging

    # We've opened the file. Switch to the iterator.
    return _file_reader(obconversion, obmol, notatend)

def _stdin_reader(obconversion, obmol):
    "This is an internal function"
    # Read structures from stdin.

    # The current release of scripting for OpenBabel doesn't let me
    # use C++'s std::cin as the input stream so I need to fake it
    # using "/dev/stdin". That works on Macs, Linux, and FreeBSD but
    # not Windows.

    # Python says that it's in charge of checking for ^C. When I pass
    # control over to OpenBabel, Python is still in charge of checking
    # for ^C, but it won't do anything until control returns to Python.

    # I found it annoying that if I started the program, which by
    # default expects SMILES from stdin, then I couldn't hit ^C to
    # stop it. My solution was to stay in Python until there's
    # information on stdin, and once that's happened, call OpenBabel.

    import select
    try:
        select.select([sys.stdin], [], [sys.stdin])
    except KeyboardInterrupt:
        raise SystemExit()

    # There's data. Pass parsing control into OpenBabel.
    notatend = obconversion.ReadFile(obmol, "/dev/stdin")
    return _file_reader(obconversion, obmol, notatend)

def _file_reader(obconversion, obmol, notatend):
    while notatend:
        yield obmol.GetTitle(), obmol
        obmol.Clear()
        notatend = obconversion.Read(obmol)
        # How do I detect if the input contains a failure?
